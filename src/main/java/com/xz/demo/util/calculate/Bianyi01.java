package com.xz.demo.util.calculate;

public class Bianyi01 {

    public static void main(String[] args) {
        /*
         *  1 编译器的自动优化 在设置的时候，如果不超过范围，是可以自动转化的 比如
         * */
        // 127 在byte的范围之内 -2 （n-1）次方  到 正的 2 （n-1）次方 -1 因为数字127默认是int类型类型的，这句话在编译器里面会自动转化，只要不超过设置的范围
        byte b = 127;
        System.out.println(b);

        byte c = (byte) -129;
        System.out.println(c);
        byte d = (byte) 128;
        System.out.println(d);

        /*
            原因：我们知道byte类型的取数范围是-128~127，而且这个是编码方式决定的，Java中正数用源码表示，负数用补码表示，第一位是符号位。
            -129的源码为：10000000 00000000 00000000 10000001
            因为-129超过了byte类型的存储区间，所以-129为int类型（32位），在计算机中负数用补码表示（取反+1），如下
            11111111 11111111 11111111 01111111
            而byte类型只占8位，因此11111111 11111111 11111111为溢出位，用byte类型只存储到01111111这一部分，也就是127
            128也超出了byte类型的存储空间，所以128为int类型，在计算机中正数用源码表示，128用下面的补码表示。
            00000000 00000000 00000000 10000000
            而byte类型只占8位，因此00000000 00000000 00000000为溢出位，用byte类型只存储到10000000这一部分，也就是-128
—————————**/



        float f1 = 1.0f;

        float f = f1+1.0f;

        short s1 = 5;

        short s2 = 8;

        //short s = s1+s2;  这个是变量 在Javac 编译器里面  s1 s2 虽然等于5 ，8 但是这是变量，变量意味着值可以改变，是风险性操作，所以编译器不让通过.会出现编译错误
        //但是s3 不会报错，因为在编译器，编译期间，5 和 8 相对于s3 已经确定出来了，就可以直接先算出来这个常量的喝，再来判断是否在该范围内，但是上面float可以，因为就算float
        // 变量不管怎么赋值，那赋值之后的肯定也是一个float类型，但是short例子不同，如果复制超过范围了 就会报编译错。

        short s3 = 5+8;



    }
}
